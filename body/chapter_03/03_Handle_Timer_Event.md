<div id="sect_title_img_3_3"></div>

<div id="sect_title_text"></div>

# タイマのイベントを扱う

<div id="preface"></div>

###### [3-1節](01_Handle_Mouse_Click_Event.md) と [3-2節](02_Handle_Keyboard_Key_Event.md) はでユーザからの入力イベントを扱いましたが、他にもタイマを設定してある時間が経過したときにイベントを発生させることができます。本節では、タイマを使って一定間隔でイベントを発生させる方法を紹介します。

## 作成するアドオンの仕様

タイマのイベントを扱う方法を理解するため、定期的にイベントが発生することを利用し、以下の機能を持つアドオンを作成します。

* *3Dビュー* エリアのプロパティパネルの項目 *一定間隔でオブジェクトを移動* に、オブジェクトを一定間隔で移動するモードを開始/終了するためのボタンを配置する
  * 項目 *一定間隔でオブジェクトを移動* は、オブジェクトモードかつ選択中のオブジェクトがメッシュ型の場合のみ表示する
* オブジェクトを一定間隔で移動するモードでは、開始ボタンを押した時に選択していたオブジェクトの位置を中心として、オブジェクトが一定間隔で円を描くように移動する


## アドオンを作成する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考にして以下のソースコードを入力し、ファイル名を ```sample_3_3.py``` として保存してください。


[import](../../sample/src/chapter_03/sample_3_3.py)

## アドオンを使用する

### アドオンを有効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に、作成したアドオンを有効化するとコンソールウィンドウに以下の文字列が出力されます。

```sh
サンプル3-3: アドオン「サンプル3-3」が有効化されました。
```

<div id="sidebyside"></div>

|プロパティパネルを表示し、項目 *一定間隔でオブジェクトを移動* が追加されていることを確認します。|![3-3節 アドオン有効化](https://dl.dropboxusercontent.com/s/18venqljmdtefp3/enable_add-on.png "3-3節 アドオン有効化")|
|---|---|



### アドオンの機能を使用する

有効化したアドオンの機能を使い、動作を確認します。

<div id="process_title"></div>

##### Work

<div id="process"></div>

|<div id="box">1</div>|*3Dビュー* エリアのプロパティパネル上の項目 *一定間隔でオブジェクトを移動* に配置されている *開始* ボタンを押します。|![3-3節 アドオンの使用 手順1](https://dl.dropboxusercontent.com/s/t6gn930juq6fh1n/use_add-on_1.png "3-3節 アドオンの使用 手順1")|
|---|---|---|

<div id="process_sep"></div>

---

<div id="process"></div>

|<div id="box">2</div>|約0.1秒ごとに、選択中のオブジェクトが開始ボタンを押した時の位置を中心に円を描くように移動します。|![3-3節 アドオンの使用 手順2](https://dl.dropboxusercontent.com/s/fk84kkwzwtzyu7j/use_add-on-2.png "3-3節 アドオンの使用 手順2")|
|---|---|---|

<div id="process_sep"></div>

---

<div id="tips"></div>

開始ボタンを押した後の移動中も、通常と同じ方法でオブジェクトを移動することができますが、タイマイベントを契機に元の場所に自動的に戻ります。

<div id="process"></div>

|<div id="box">3</div>|*終了* ボタンを押すとオブジェクトが移動しなくなり、開始ボタンを押した時の位置にオブジェクトが移動します。|![3-3節 アドオンの使用 手順3](https://dl.dropboxusercontent.com/s/ori4aazvlzoxhlf/use_add-on-3.png "3-3節 アドオンの使用 手順3")|
|---|---|---|

<div id="process_sep"></div>

---

<div id="process_start_end"></div>

---


### アドオンを無効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に有効化したアドオンを無効化すると、コンソールウィンドウに以下の文字列が出力されます。

```sh
サンプル3-3: アドオン「サンプル3-3」が無効化されました。
```


## ソースコードの解説

本節ではタイマイベントを扱う処理と作業時間計測の処理に絞って、サンプルのソースコードを解説します。これまで説明してきた内容など、説明するまでもない処理については説明を省いています。処理がわからなくなってしまった時は、ソースコード中のコメントや前節までの解説を参考にしてください。本節で紹介したアドオンのソースコードに関して、ポイントとなる点は以下のとおりです。

* タイマの登録、登録解除
* オブジェクトの位置取得、更新
* パネル表示/非表示切り替え

本節では、オブジェクトを一定間隔で移動するモードをモーダルモードと書いている部分があります。以降本節では、モーダルモードと書かれていたらオブジェクトを一定間隔で移動するモードとして読み進めてよいです。

### アドオン内で利用するプロパティを定義する

本節のサンプルでも複数のクラス間でデータを共有します。サンプルで定義しているプロパティ一覧を次に示します。

|プロパティ|意味|
|---|---|
|```running```|オブジェクトを一定間隔で移動するモード中の時に値が ```True``` となる|


### タイマの登録

タイマイベントを発生させるためには、タイマを登録する必要があります。タイマの登録処理は、次に示す ```__handle_add()``` メソッドで行います。

[import:"add_timer", unindent:"true"](../../sample_raw/src/chapter_03/sample_3_3.py)

タイマの登録は、```context.window_manager.event_timer_add()``` 関数で行います。```context.window_manager.event_timer_add()``` 関数は次に示す引数を取り、戻り値としてタイマのハンドラを返します。

|引数|値の意味|
|---|---|
|第1引数|タイマイベントを発生させる間隔を秒単位で指定|
|第2引数|タイマの登録先ウィンドウ|

本節のサンプルでは第1引数に ```0.1``` を指定することで、タイマによるイベントを0.1秒ごとに発生させています。第2引数には、作業時間の測定を開始した時に押したボタンが存在するウィンドウにタイマイベントを発生させたいため、```context.window``` を指定します。

戻り値として返されたハンドラはタイマの登録を解除する時に使用するため、インスタンス変数 ```timer``` に保存します。

最後にモーダルモードへ移行しますが、必ずしも ```__handle_add()``` メソッド内で行う必要はありません。```__handle_add()``` メソッド自体が ```invoke()``` メソッドから呼び出されているので、[3-1節](01_Handle_Mouse_Click_Event.md) や [3-2節](02_Handle_Keyboard_Key_Event.md) と同様に、```invoke()``` メソッドの処理内で ```context.window_manager.modal_handler_add()``` 関数を呼んでモーダルモードへ移行しても良いです。


### タイマの登録を解除

タイマを登録すると、タイマの登録を解除するまでタイマイベントを送り続けます。このため、タイマが不要になったら登録を解除する必要があります。

タイマの登録解除処理は、次に示す ```__handle_remove()``` メソッドで行っています。

[import:"remove_timer", unindent:"true"](../../sample_raw/src/chapter_03/sample_3_3.py)

タイマの登録解除は ```context.window_manager.event_timer_remove()``` 関数で行いますが、引数には ```context.window_manager.modal_handler_add()``` 関数の戻り値として返されたタイマのハンドラを渡す必要があります。本節のサンプルでは、タイマのハンドラを保存したインスタンス変数 ```timer``` を引数に渡し、大麻の登録を解除しています。

登録解除済のタイマのハンドラにアクセスすることによる不正な動作を避けるために、タイマのハンドラを保存したインスタンス変数に ```None``` を代入します。


### modalメソッド

タイマイベントが発生すると、```modal()``` メソッドが呼ばれます。

[3-1節](01_Handle_Mouse_Click_Event.md) や [3-2節](02_Handle_Keyboard_Key_Event.md) と同様に ```modal()``` メソッドの最初では、*3Dビュー* エリアの画面更新と ```modal()``` メソッドの終了判定処理を行います。

[import:"handle_timer_event", unindent:"true"](../../sample_raw/src/chapter_03/sample_3_3.py)

[3-1節](01_Handle_Mouse_Click_Event.md) や [3-2節](02_Handle_Keyboard_Key_Event.md) で説明したように、```modal()``` メソッドはキーボードやマウスのイベントが発生した時にも呼ばれます。このためタイマイベントが発生した時のみオブジェクトを移動するようにしないと、キーボードやマウスの入力イベントが発生するたびにオブジェクトが移動してしまいます。そこで発生したイベントがタイマイベントではない時に ```{'PASS_THROUGH'}``` を返すことで、マウスやキーボードからのイベントが発生した時にオブジェクトが移動しないようにします。

[import:"stop_moving_object", unindent:"true"](../../sample_raw/src/chapter_03/sample_3_3.py)

続いて、終了ボタンが押された時にモーダルモードを終了する処理を実行します。終了ボタンが押されると、```invoke()``` メソッドの処理内で ```props.running``` が  ```False``` に設定されます。```props.running``` が ```False``` に設定された時は、```__handle_remove()``` メソッドを呼び出してタイマを登録解除した後にオブジェクトを初期位置に移動し、```{'FINISHED'}``` を返してモーダルモードを終了します。

オブジェクトを初期位置に移動するために、メンバ変数 ```__orig_obj_loc``` に保存された初期位置を使っています。メンバ変数 ```__orig_obj_loc``` にオブジェクトの初期位置を保存する処理については、```invoke()``` メソッドで説明します。

最後に、```__update_object_location()``` メソッドを呼び出してオブジェクトの位置を更新します。```__update_object_location()``` メソッド内で行なっている処理については、次に説明します。


#### オブジェクトの位置を更新する

タイマイベントが発生したときにオブジェクトの位置を更新する処理は、```__update_object_location()``` メソッドで行います。

[import:"update_object_location", unindent:"true"](../../sample_raw/src/chapter_03/sample_3_3.py)

オブジェクトの初期位置はインスタンス変数 ```__orig_obj_loc``` に保存されているため、オブジェクトの初期位置に移動先の位置を相対座標で加えることで、オブジェクトの位置を更新します。オブジェクトの位置は ```obj.location``` から参照・変更することができます。

更新するオブジェクトの位置(x, y, z)=(X, Y, Z)は、初期位置を(x, y, z)=(ix, iy, iz)、半径r、回転角度aとして次の計算式で求めます。

```
(X, Y, Z) = (ix + r * sin(a), iy + r * cos(a), iz)
```

本節のサンプルでは、タイマイベントが発生して ```__update_object_location()``` メソッドが呼び出されると、```self.__count``` をカウントアップします。回転角a（ソースコード上の変数 ```angle```）は ```self.__count``` が増えるに従って増加するため、初期位置を中心としてオブジェクトの位置が円を描くように回転します。

本節のサンプルでは、オブジェクトが初期位置を中心として半径（ソースコード上の変数 ```radius```）```5.0``` 、角速度（ソースコード上の変数 ```angular_velocity```）```3.0``` で回転します。


### invokeメソッド

[import:"store_obj_loc", unindent:"true"](../../sample_raw/src/chapter_03/sample_3_3.py)

オブジェクトの初期位置は、```invoke()``` メソッドの開始ボタンが押された時（```props.running``` が ```False``` の時）の処理の中で、インスタンス変数である ```__orig_obj_loc``` にオブジェクトをキーとして保存します。

本節のサンプルでは選択中のメッシュ型のオブジェクトを移動の対象としているため、移動対象のオブジェクトを選別した上でオブジェクトの初期位置を保存する必要があります。

オブジェクトが選択中であることは、```obj.select``` が ```True``` であることを確認すればよいです。また、オブジェクトの型は変数 ```obj.type``` で判定できます。本節のサンプルでは、メッシュ型のオブジェクトであることを確認したいため、確認するためのコードは ```obj.type == 'MESH'``` となります。

|型|意味|
|---|---|
|```MESH```|メッシュ|
|```CURVE```|カーブ|
|```SURFACE```|サーフェス|
|```META```|メタオブジェクト|
|```FONT```|テキストオブジェクト|
|```ARMATURE```|アーマチュア|
|```LATTICE```|ラティス|
|```EMPTY```|空のオブジェクト|
|```CAMERA```|カメラ|
|```LAMP```|ランプ|
|```SPEAKER```|スピーカー|


<div id="tips"></div>

サンプルでは、obj.location.copy() に示された copy() メソッドを用いて、位置情報を示す Vector オブジェクトのコピーを作っています。これは、Vector オブジェクトのコピーを作らないと、\__orig_obj_loc オブジェクトの位置情報の参照を持ち続けることになってしまうからです。初期位置情報として保存していたはずが、 \__update_object_location() メソッドで移動後の位置情報に書き換えられてしまうため、オブジェクトの位置更新処理が正しく動作しません。このように、BlenderのAPIを変数に代入する場合は、参照を持つのかコピーを持つのかに気をつけて実装する必要があります。


最後に、```__update_object_location()``` メソッドを呼び出してオブジェクトの位置を更新します。


### パネル表示/非表示切り替え

*3Dビュー* エリアのプロパティパネルに追加した項目 *一定間隔でオブジェクトを移動* は、[2-8節](../chapter_02/08_Control_Blender_UI_1.md) で説明した ```poll()``` クラスメソッドで項目を表示する条件を絞っています。本節のサンプルでは、最低でも1つのメッシュ型のオブジェクトが選択され、かつオブジェクトモードの時にパネルを表示します。オブジェクトの型がメッシュ型かつ選択された状態であるかを判定する方法は先ほど説明した通り、```obj.type``` が ```MESH``` かつ ```obj.select``` が ```True``` の場合です。そして、現在のオブジェクトが *オブジェクトモード* と *エディットモード* のどちらの状態にあるのかは ```obj.mode``` により取得することができるため、先ほどの項目の表示条件を満たしたことを判定するコードは次のようになります。

[import:"poll", unindent:"true"](../../sample_raw/src/chapter_03/sample_3_3.py)

項目を表示する条件を満たすオブジェクトが存在しない場合、```False``` を返すことで項目を表示しないようにします。

なお、```obj.mode``` には次のような値が設定され、オブジェクトが現在どのようなモードであるかを確認したい場合に利用することができます。

|値|モード|
|---|---|
|```OBJECT```|オブジェクトモード|
|```EDIT```|エディットモード|
|```SCULPT```|スカルプトモード|
|```VERTEX_PAINT```|頂点ペイント|
|```WEIGHT_PAINT```|ウェイトペイント|
|```TEXTURE_PAINT```|テクスチャペイント|
|```PARTICLE_EDIT```|パーティクル編集|
|```POSE```|ポーズモード|


<div id="tips"></div>

現在 *オブジェクトモード* か *エディットモード* かを判定する方法として、```bpy.context.mode``` を参照して ```'OBJECT'``` であることを確かめる方法もあります。また、*オブジェクトモード* 時のみプロパティパネルに項目を表示したい場合、[2-8節](../chapter_02/08_Control_Blender_UI_1.md) で示したパネルクラスのクラス変数 ```bl_context``` に ```objectmode``` を指定することでも実現可能です。


## まとめ

本節では、タイマのイベントを扱う方法を説明しました。タイマを使うと指定した間隔でイベントを発生させることができるため、定期的に処理を実行するような機能を実現することができます。

[3-1節](01_Handle_Mouse_Click_Event.md) から本節まで3節にわたってイベントを扱う処理を説明しましたが、イベントを扱う場合はいずれの場合においても、```modal()``` メソッドや ```invoke()``` メソッドを実装する必要があることが理解できたかと思います。


<div id="point"></div>

### ポイント

<div id="point_item"></div>

* タイマを登録することで、一定間隔でタイマイベントを発生させることができる
* タイマの登録は ```context.window_manager.event_timer_add()``` 関数で行い、不要になったタイマは ```context.window_manager.event_timer_remove()``` 関数で登録を解除する
* タイマイベントが発生すると、```context.window_manager.modal_handler_add()``` の引数に指定したインスタンスの ```modal()``` メソッドが呼び出され、引数 ```event``` のメンバ変数 ```event.type``` に ```TIMER``` が設定される
